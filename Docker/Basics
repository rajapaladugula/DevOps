Build Docker Image from a Dockerfile: docker build -t <tag_name> <PATH | URL | -file>
PATH: local path in the machine; URL: Git Repo; -f /path/to/file(if exists at a dfferent location)

Create a Docker Image from an existing Container: docker commit <CONTAINER_ID> <NEW_REPOSITORY_NAME>

Remove a Docker Image: docker rmi <Container_ID>
Remove all Docker Images: docker image prune -a
Remove a Docker Container: docker rm <Container_ID>
Remove all stopped containers: docker system prune

Create a Docker container from Docker image: docker run -d -p 3000:8080 --name=my_app --network <Network_Name> <image name>
-d : Detach (Runs container in background)
--name : Desired name of the container
-p (publish): Bind port on host:port on container -p | -P (publish all) maps port dynamically
--network : Network associated

lynx: Terminal based browser -> lynx localhost:xxxx

Docker resources storage path: /var/lib/docker/*
Docker Logs: docker logs <Container_ID>
Run Docker Interactively: docker run -it <image>
Fetch IP address of a container: docker inspect <Container_ID | Name>
Detach from a container without stopping: CTRL+p | CTRL+q
Interact with the running container --> docker attach <CONTAINER_ID>

3 Networks: bridge-host-none $docker network ls
(default)bridge n/w has access to interact with every other container and also reach outside world.
$docker network create --driver bridge <Network_Name>
hosts n/w adds containers to hosts n/w directly, no isolation b/w hosts & containers. ($docker run -d --network=host)
none has no n/w access $docker run -d --network=none
Show all containers on N/W: arp-scan --interface=eth0 --localnet

MOUNT:
1. docker run -d --mount type=bind,src="/opt/demo", dst=/logs <Image_Name>
src is the path in the host; dst is the path in the container, which are binded together.	
2. docker run -d --mount type=volume,src="<VOLUME_NAME>", dst=/logs <Image_Name> --> need not mention the fully qualified name of the src in host, docker manages it.
Create a new Docker volume : Docker volume create <VOLUME_NAME>
To find where the volume is mounted: docker volume inspect <VOLUME_NAME | src>
3. docker run -d --mount type=tmpfs,dst=/logs <Image_Name> --> In Memory storage isolated from host, so no src mentioned.  

Connect a volume to the container : docker run -it --name=<Container_Name> -p 8083:8080 -p 50000:50000 -v </path/to/host | VOLUME_NAME>:/var/jenkins_home <Image_Name>
-v | --volume | --mount : attach a created volume; --mount is the path/on/host
Remove unused volumes: docker volume prune

Tag an image: docker tag <image> <username>/<repository>:<tag>
publish image: docker push <username>/<repository>:<tag>
pull & run image from remote repo: docker run -p 4000:80 <username>/<repository>:<tag>

DOCKER_FILE INSTRUCTIONS:::
FROM : base image to be used ; FROM python:2.7-slim --> Use an official Python runtime as a parent image whose version is 2.7-slim.
RUN : takes commands as arg's and runs. installs packages specified like jenkins, java.. actually used to build image.
ADD: has 2 arg's --> ADD /source/file /dest/file Copies files from host to container. also supports extracting local tar file to dest file.
COPY: copy files from host to the container; COPY . /app --> Copy the current directory contents into the container at /app.
CMD : runs the commands specified similar to RUN. unlike RUN, it is not executed during build, but when container is instantained using image built finally.
ENTRYPOINT : 1st command to be executed that determines location where to start from.
URL : Git repository location.
MAINTAINER : name of the maintainer.
USER : UID/username of the user who can execute container.
VOLUME : enable access from your container to a directory on host machine(mount)
ENV : Define environment variable key-value pair --> ENV NAME World
EXPOSE : EXPOSE 80 --> used to associate specified port to enable n/w access of running process inside container.
WORKDIR : Set the working directory; WORKDIR /desired/path --> used to set path where command defined with CMD is to be executed.

SORT Unique:  cat /var/log/cron | cut -d " " -f4 | sort |uniq
-f 4 is the fourth row.

Tail to refresh every sec: tail -F -s1 /path/to/logs
